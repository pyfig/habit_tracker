This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/
  app/
    routes/
      auth.py
      habits.py
      marks.py
    auth.py
    db.py
    main.py
    models.py
    schemas.py
  Dockerfile
  requirements.txt
frontend/
  api.js
  app.js
  auth.js
  autorestart.sh
  calendar.js
  Dockerfile
  habits-handlers.js
  habits.js
  index.html
  nginx.conf
  styles.css
.gitignore
docker-compose.yml
LICENSE
main.sh
package.json
README_RUS.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/app/routes/auth.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from app.schemas import UserCreate, UserRead, Token
from app.auth import hash_password, create_access_token
from app.db import get_db
from app.auth import verify_password
from app.models import User
import uuid

router = APIRouter(prefix="/auth", tags=["auth"])

def get_user_by_username(username: str, db: Session = Depends(get_db)):
    return db.query(User).filter(User.username == username).first()

@router.post("/register", response_model=UserRead)
async def register(user_data: UserCreate, db: Session = Depends(get_db)):
    db_user = get_user_by_username(user_data.username, db)
    if db_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered"
        )
    
    hashed_password = hash_password(user_data.password)
    new_user = User(
        id=uuid.uuid4(),
        username=user_data.username,
        password=hashed_password
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user

@router.post("/login", response_model=Token)
async def login(user_data: UserCreate, db: Session = Depends(get_db)):
    user = get_user_by_username(user_data.username, db)
    if not user or not verify_password(user_data.password, user.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password"
        )
    
    access_token = create_access_token({"sub": str(user.id)})
    return {"access_token": access_token, "token_type": "bearer"}
</file>

<file path="backend/app/auth.py">
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
import os
from dotenv import load_dotenv
from app.db import get_db
from app.models import User
from uuid import UUID

load_dotenv()

# Настройки JWT
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-for-jwt")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Настройки хеширования паролей
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.id == UUID(user_id)).first()
    if user is None:
        raise credentials_exception
    return user
</file>

<file path="backend/app/db.py">
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://postgres:postgres@db:5432/habit_tracker")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="backend/Dockerfile">
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
</file>

<file path="backend/requirements.txt">
fastapi==0.95.0
uvicorn==0.21.1
sqlalchemy==2.0.7
psycopg2-binary==2.9.5
pydantic==1.10.7
python-jose==3.3.0
passlib==1.7.4
python-dotenv==1.0.0
bcrypt==4.0.1
python-multipart==0.0.6
</file>

<file path="frontend/Dockerfile">
FROM nginx:alpine

WORKDIR /usr/share/nginx/html

# Копируем файлы фронтенда
COPY . .

# Копируем конфигурацию Nginx
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 xdshkaaa

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="main.sh">
#!/bin/bash

set -e  # Остановить скрипт при ошибке

echo "Останавливаю и удаляю контейнеры..."
docker-compose down -v

echo "Пересобираю образы без использования кэша..."
docker-compose build --no-cache

echo "Запускаю контейнеры в фоновом режиме..."
docker-compose up -d

echo "Открываю http://localhost:3000 в браузере..."
if command -v xdg-open > /dev/null; then
    xdg-open http://localhost:3000
elif command -v open > /dev/null; then
    open http://localhost:3000
else
    echo "Не удалось автоматически открыть браузер. Перейдите на http://localhost:3000 вручную."
fi
</file>

<file path="package.json">
{
  "name": "habit_tracker",
  "version": "1.0.0",
  "description": "Habit Tracker Frontend",
  "main": "index.js",
  "scripts": {
    "dev": "vite"
  },
  "dependencies": {},
  "devDependencies": {
    "vite": "^4.0.0"
  }
}
</file>

<file path="backend/app/routes/marks.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from uuid import UUID
from datetime import date

from app.db import get_db
from app.models import Mark, Habit, User
from app.schemas import MarkCreate, MarkRead
from app.auth import get_current_user

router = APIRouter(prefix="/marks", tags=["marks"])

@router.post("/", response_model=MarkRead)
async def create_mark(mark_data: MarkCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    habit = db.query(Habit).filter(Habit.id == mark_data.habit_id, Habit.user_id == current_user.id).first()
    if not habit:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Habit not found or doesn't belong to current user")
    
    existing_mark = db.query(Mark).filter(Mark.habit_id == mark_data.habit_id, Mark.date == mark_data.date).first()
    if existing_mark:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Mark for this date already exists")
    
    new_mark = Mark(
        habit_id=mark_data.habit_id,
        date=mark_data.date
    )
    db.add(new_mark)
    db.commit()
    db.refresh(new_mark)
    return new_mark

@router.get("/habit/{habit_id}", response_model=List[MarkRead])
async def get_marks_by_habit(habit_id: UUID, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    habit = db.query(Habit).filter(Habit.id == habit_id, Habit.user_id == current_user.id).first()
    if not habit:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Habit not found or doesn't belong to current user")
    
    marks = db.query(Mark).filter(Mark.habit_id == habit_id).all()
    return marks

@router.delete("/{mark_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_mark(mark_id: UUID, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    mark = db.query(Mark).join(Habit).filter(
        Mark.id == mark_id,
        Habit.user_id == current_user.id
    ).first()
    
    if not mark:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Mark not found or doesn't belong to current user")
    
    db.delete(mark)
    db.commit()
    return None
</file>

<file path="backend/app/schemas.py">
from pydantic import BaseModel, Field, validator
from uuid import UUID
from typing import Optional, List
from datetime import date
import re

class UserCreate(BaseModel):
    username: str
    password: str
    
    @validator('username')
    def username_must_be_valid(cls, v):
        if not re.match(r'^[a-zA-Z0-9_-]{3,20}$', v):
            raise ValueError('Имя пользователя должно содержать от 3 до 20 символов и может включать только буквы, цифры, дефис и подчеркивание')
        return v
        
    @validator('password')
    def password_must_be_valid(cls, v):
        if not re.match(r'^[a-zA-Z0-9@#$%^&+=]{6,20}$', v):
            raise ValueError('Пароль должен содержать от 6 до 20 символов и может включать буквы, цифры и специальные символы (@#$%^&+=)')
        return v

class UserRead(BaseModel):
    id: UUID
    username: str

    class Config:
        orm_mode = True

class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"

class HabitBase(BaseModel):
    name: str
    description: Optional[str] = None

class HabitCreate(HabitBase):
    pass

class HabitUpdate(HabitBase):
    name: Optional[str] = None

class HabitRead(HabitBase):
    id: UUID
    user_id: UUID

    class Config:
        orm_mode = True

class MarkCreate(BaseModel):
    habit_id: UUID
    date: date

class MarkRead(BaseModel):
    id: UUID
    habit_id: UUID
    date: date

    class Config:
        orm_mode = True
</file>

<file path="frontend/autorestart.sh">
#!/bin/bash

# yet another debug 
docker-compose down -v
docker-compose build --no-cache 
docker-compose up -d
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    depends_on:
      - db
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/habit_tracker
    networks:
      - habit-network
    restart: always

  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend
    networks:
      - habit-network
    restart: always

  db:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=habit_tracker
    ports:
      - "5432:5432"
    networks:
      - habit-network
    restart: always

networks:
  habit-network:
    driver: bridge

volumes:
  postgres_data:
</file>

<file path="backend/app/models.py">
from sqlalchemy import Column, String, Text, ForeignKey, Date, Boolean  
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
import uuid

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String, unique=True, nullable=False)
    password = Column(String, nullable=False)
    
    habits = relationship("Habit", back_populates="user", cascade="all, delete-orphan")

class Habit(Base):
    __tablename__ = "habits"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    name = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    archived = Column(Boolean, default=False)
    completed = Column(Boolean, default=False)  # Новое поле для выполнения

    user = relationship("User", back_populates="habits")
    marks = relationship("Mark", back_populates="habit", cascade="all, delete-orphan")

class Mark(Base):
    __tablename__ = "marks"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    habit_id = Column(UUID(as_uuid=True), ForeignKey("habits.id"), nullable=False)
    date = Column(Date, nullable=False)
    
    habit = relationship("Habit", back_populates="marks")
</file>

<file path="frontend/app.js">
// Глобальные переменные и инициализация
let currentUser = null;

// Функция для инициализации приложения
function initApp() {
    // Проверяем, авторизован ли пользователь
    if (isAuthenticated()) {
        // Если авторизован, загружаем данные пользователя
        loadUserData();
    }
    
    // Инициализируем обработчики событий
    initEventListeners();
}

// Функция для загрузки данных пользователя
function loadUserData() {
    // Загружаем привычки пользователя
    loadHabits();
}

// Функция для инициализации обработчиков событий
function initEventListeners() {
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                modal.style.display = 'none';
            });
        }
    });
}

// Запускаем инициализацию приложения при загрузке страницы
document.addEventListener('DOMContentLoaded', initApp);
</file>

<file path="frontend/auth.js">
// Управление аутентификацией

// Получение элементов формы
const authContainer = document.getElementById('auth-container');
const appContent = document.getElementById('app-content');
const loginForm = document.getElementById('login-form-element');
const registerForm = document.getElementById('register-form-element');
const loginError = document.getElementById('login-error');
const registerError = document.getElementById('register-error');
const logoutBtn = document.getElementById('logout-btn');
const tabBtns = document.querySelectorAll('.tab-btn');
const authForms = document.querySelectorAll('.auth-form');

// Функция для сохранения токена в localStorage
function saveToken(token) {
    localStorage.setItem('token', token);
}

// Функция для получения токена из localStorage
function getToken() {
    const token = localStorage.getItem('token');
    return token;
}

// Функция для удаления токена из localStorage
function removeToken() {
    localStorage.removeItem('token');
}

// Функция для проверки авторизации пользователя
function isAuthenticated() {
    return !!getToken();
}

// Функция для переключения между формами входа и регистрации
function switchAuthForm(formId) {
    authForms.forEach(form => {
        form.classList.remove('active');
    });
    
    tabBtns.forEach(btn => {
        btn.classList.remove('active');
    });
    
    document.getElementById(`${formId}-form`).classList.add('active');
    document.querySelector(`[data-tab="${formId}"]`).classList.add('active');
}

// Функция для переключения между контейнерами аутентификации и приложения
function switchContainer() {
    if (isAuthenticated()) {
        authContainer.classList.add('hidden');
        appContent.classList.remove('hidden');
        loadUserData(); // Загрузка данных пользователя
    } else {
        authContainer.classList.remove('hidden');
        appContent.classList.add('hidden');
    }
}

// Обработчик отправки формы входа
loginForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const username = document.getElementById('login-username').value;
    const password = document.getElementById('login-password').value;
    
    try {
        loginError.textContent = '';
        const response = await authApi.login(username, password);
        saveToken(response.access_token);
        switchContainer();
    } catch (error) {
        loginError.textContent = error.message || 'Ошибка входа. Проверьте имя пользователя и пароль.';
    }
});

// Обработчик отправки формы регистрации
registerForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const username = document.getElementById('register-username').value;
    const password = document.getElementById('register-password').value;
    const passwordConfirm = document.getElementById('register-password-confirm').value;
    
    if (password !== passwordConfirm) {
        registerError.textContent = 'Пароли не совпадают';
        return;
    }
    
    // Проверка формата имени пользователя
    if (!/^[a-zA-Z0-9_-]{3,20}$/.test(username)) {
        registerError.textContent = 'Имя пользователя должно содержать от 3 до 20 символов и может включать только буквы, цифры, дефис и подчеркивание';
        return;
    }
    
    // Проверка формата пароля
    if (!/^[a-zA-Z0-9@#$%^&+=]{6,20}$/.test(password)) {
        registerError.textContent = 'Пароль должен содержать от 6 до 20 символов и может включать буквы, цифры и специальные символы (@#$%^&+=)';
        return;
    }
    
    try {
        registerError.textContent = '';
        await authApi.register(username, password);
        // После успешной регистрации выполняем вход
        const response = await authApi.login(username, password);
        saveToken(response.access_token);
        switchContainer();
    } catch (error) {
        registerError.textContent = error.message || 'Ошибка регистрации. Попробуйте другое имя пользователя.';
    }
});

// Обработчик нажатия на кнопку выхода
logoutBtn.addEventListener('click', () => {
    removeToken();
    switchContainer();
});

// Обработчики переключения вкладок
tabBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        const tabId = btn.getAttribute('data-tab');
        switchAuthForm(tabId);
    });
});

// Проверка аутентификации при загрузке страницы
document.addEventListener('DOMContentLoaded', () => {
    switchContainer();
});
</file>

<file path="frontend/calendar.js">
// Управление календарем отметок

// Получение элементов
const calendarElement = document.getElementById('calendar');
const currentMonthElement = document.getElementById('current-month');
const prevMonthBtn = document.getElementById('prev-month');
const nextMonthBtn = document.getElementById('next-month');

// Глобальные переменные
let currentDate = new Date();
let currentMonth = currentDate.getMonth();
let currentYear = currentDate.getFullYear();
let allMarks = {}; // Объект для хранения отметок по привычкам

// Названия месяцев
const monthNames = [
    'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь',
    'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
];

// Названия дней недели
const weekdayNames = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];

// Функция для загрузки отметок для всех привычек
async function loadAllMarks() {
    try {
        const token = getToken();
        allMarks = {};
        
        // Загружаем отметки для каждой привычки
        for (const habit of habits) {
            const marks = await marksApi.getByHabit(habit.id, token);
            allMarks[habit.id] = marks;
        }
        
        renderCalendar();
    } catch (error) {
        console.error('Ошибка при загрузке отметок:', error);
    }
}

// Функция для получения дней в месяце
function getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
}

// Функция для получения первого дня месяца (0 - воскресенье, 1 - понедельник, ...)
function getFirstDayOfMonth(year, month) {
    const day = new Date(year, month, 1).getDay();
    return day === 0 ? 6 : day - 1; // Преобразуем для начала недели с понедельника
}

// Функция для форматирования даты в строку YYYY-MM-DD
function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Функция для проверки, есть ли отметка на определенную дату
function hasMarkOnDate(date) {
    const dateStr = formatDate(date);
    
    // Проверяем все привычки
    for (const habitId in allMarks) {
        const habitMarks = allMarks[habitId];
        if (habitMarks.some(mark => mark.date === dateStr)) {
            return true;
        }
    }
    
    return false;
}

// Функция для отображения календаря
function renderCalendar() {
    // Обновляем заголовок с текущим месяцем и годом
    currentMonthElement.textContent = `${monthNames[currentMonth]} ${currentYear}`;
    
    // Очищаем календарь
    calendarElement.innerHTML = '';
    
    // Добавляем заголовки дней недели
    weekdayNames.forEach(day => {
        const dayElement = document.createElement('div');
        dayElement.className = 'calendar-header';
        dayElement.textContent = day;
        calendarElement.appendChild(dayElement);
    });
    
    // Получаем количество дней в текущем месяце и первый день месяца
    const daysInMonth = getDaysInMonth(currentYear, currentMonth);
    const firstDay = getFirstDayOfMonth(currentYear, currentMonth);
    
    // Добавляем пустые ячейки для дней предыдущего месяца
    for (let i = 0; i < firstDay; i++) {
        const prevMonthDate = new Date(currentYear, currentMonth, 0 - (firstDay - i - 1));
        const dayElement = document.createElement('div');
        dayElement.className = 'calendar-day other-month';
        dayElement.textContent = prevMonthDate.getDate();
        calendarElement.appendChild(dayElement);
    }
    
    // Добавляем дни текущего месяца
    const today = new Date();
    const todayDate = formatDate(today);
    
    for (let i = 1; i <= daysInMonth; i++) {
        const date = new Date(currentYear, currentMonth, i);
        const dateStr = formatDate(date);
        const dayElement = document.createElement('div');
        dayElement.className = 'calendar-day';
        dayElement.textContent = i;
        dayElement.setAttribute('data-date', dateStr);
        // Отмечаем сегодняшний день
        if (dateStr === todayDate) {
            dayElement.classList.add('today');
        }
        // Отмечаем дни с отметками
        if (hasMarkOnDate(date)) {
            dayElement.classList.add('marked');
        }
        // Блокируем будущее
        if (date > today) {
            dayElement.classList.add('disabled');
            dayElement.style.pointerEvents = 'none';
            dayElement.style.opacity = '0.5';
        } else {
            // Добавляем обработчик клика для добавления/удаления отметки
            dayElement.addEventListener('click', () => toggleMark(dateStr));
        }
        calendarElement.appendChild(dayElement);
    }
    
    // Добавляем пустые ячейки для дней следующего месяца
    const totalCells = Math.ceil((firstDay + daysInMonth) / 7) * 7;
    const remainingCells = totalCells - (firstDay + daysInMonth);
    
    for (let i = 1; i <= remainingCells; i++) {
        const nextMonthDate = new Date(currentYear, currentMonth + 1, i);
        const dayElement = document.createElement('div');
        dayElement.className = 'calendar-day other-month';
        dayElement.textContent = i;
        calendarElement.appendChild(dayElement);
    }
}
// файл: frontend/calendar.js

// После загрузки отметок обновляем календарь и список выполненных сегодня
async function loadAllMarks() {
    try {
        const token = getToken();
        allMarks = {};
        for (const habit of habits) {
            const marks = await marksApi.getByHabit(habit.id, token);
            allMarks[habit.id] = marks;
        }
        renderCalendar();
        renderCompletedToday(); // Обновляем список выполненных сегодня
    } catch (error) {
        console.error('Ошибка при загрузке отметок:', error);
    }
}



// Функция для отображения списка выполненных сегодня привычек
function renderCompletedToday() {
    const todayStr = formatDate(new Date());
    const listEl = document.getElementById('completed-today-list');
    listEl.innerHTML = '';

    // Определяем привычки, у которых есть отметка на сегодняшнюю дату
    const doneHabits = habits.filter(habit => {
        const marks = allMarks[habit.id] || [];
        return marks.some(mark => mark.date === todayStr);
    });

    if (doneHabits.length === 0) {
        listEl.innerHTML = '<li>Нет выполненных привычек</li>';
    } else {
        doneHabits.forEach(habit => {
            const li = document.createElement('li');
            li.textContent = habit.name;
            listEl.appendChild(li);
        });
    }
}

function toggleTodayMark() {
    const today = formatDate(new Date()); // Сегодняшняя дата в формате строки
    const todayElement = document.querySelector(`.calendar-day[data-date="${today}"]`);

    if (todayElement) {
        todayElement.classList.toggle('marked');
    }
}


// Функция для переключения на предыдущий месяц
function goToPrevMonth() {
    currentMonth--;
    if (currentMonth < 0) {
        currentMonth = 11;
        currentYear--;
    }
    renderCalendar();
}

// Функция для переключения на следующий месяц
function goToNextMonth() {
    currentMonth++;
    if (currentMonth > 11) {
        currentMonth = 0;
        currentYear++;
    }
    renderCalendar();
}

// Функция для добавления или удаления отметки
async function toggleMark(dateStr) {
    if (habits.length !== 1) {
        return;
    }

    const selectedHabitId = habits[0].id;
    await processMarkToggle(selectedHabitId, dateStr);
}

// файл: frontend/calendar.js

// После загрузки отметок обновляем календарь и список выполненных сегодня
async function loadAllMarks() {
    try {
        const token = getToken();
        allMarks = {};
        for (const habit of habits) {
            const marks = await marksApi.getByHabit(habit.id, token);
            allMarks[habit.id] = marks;
        }
        renderCalendar();
        renderCompletedToday(); // Обновляем список выполненных сегодня
    } catch (error) {
        console.error('Ошибка при загрузке отметок:', error);
    }
}



// Функция для обработки добавления/удаления отметки
async function processMarkToggle(habitId, dateStr) {
    try {
        const token = getToken();
        const habitMarks = allMarks[habitId] || [];
        
        // Проверяем, есть ли уже отметка на эту дату
        const existingMark = habitMarks.find(mark => mark.date === dateStr);
        
        if (existingMark) {
            // Удаляем отметку
            await marksApi.delete(existingMark.id, token);
            allMarks[habitId] = habitMarks.filter(mark => mark.id !== existingMark.id);
        } else {
            // Добавляем отметку
            const newMark = await marksApi.create({
                habit_id: habitId,
                date: dateStr
            }, token);
            
            if (!allMarks[habitId]) {
                allMarks[habitId] = [];
            }
            
            allMarks[habitId].push(newMark);
        }
        
        renderCalendar();
    } catch (error) {
        console.error('Ошибка при обновлении отметки:', error);
    }
}

// Обработчики событий для кнопок переключения месяцев
prevMonthBtn.addEventListener('click', goToPrevMonth);
nextMonthBtn.addEventListener('click', goToNextMonth);

// Функция для обновления календаря
function updateCalendar() {
    loadAllMarks();
}

// Инициализация календаря при загрузке страницы
renderCalendar();
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Трекер привычек</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="app-container">
        <div id="auth-container" class="container">
            <div class="tabs">
                <button class="tab-btn active" data-tab="login">Вход</button>
                <button class="tab-btn" data-tab="register">Регистрация</button>
            </div>
            
            <div id="login-form" class="auth-form active">
                <h2>Вход в систему</h2>
                <form id="login-form-element">
                    <div class="form-group">
                        <label for="login-username">Имя пользователя</label>
                        <input type="text" id="login-username" required>
                    </div>
                    <div class="form-group">
                        <label for="login-password">Пароль</label>
                        <input type="password" id="login-password" required>
                    </div>
                    <button type="submit" class="btn primary-btn">Войти</button>
                </form>
                <div id="login-error" class="error-message"></div>
            </div>
            
            <div id="register-form" class="auth-form">
                <h2>Регистрация</h2>
                <form id="register-form-element">
                    <div class="form-group">
                        <label for="register-username">Имя пользователя</label>
                        <input type="text" id="register-username" required>
                    </div>
                    <div class="form-group">
                        <label for="register-password">Пароль</label>
                        <input type="password" id="register-password" required>
                    </div>
                    <div class="form-group">
                        <label for="register-password-confirm">Подтвердите пароль</label>
                        <input type="password" id="register-password-confirm" required>
                    </div>
                    <button type="submit" class="btn primary-btn">Зарегистрироваться</button>
                </form>
                <div id="register-error" class="error-message"></div>
            </div>
        </div>
        
        <div id="app-content" class="container hidden">
            <header>
                <h1>Трекер привычек</h1>
                <button id="logout-btn" class="btn secondary-btn">Выйти</button>
            </header>
            
            <div class="content-wrapper">
                <div class="habits-section">
                    <div class="habits-header">
                        <h2>Мои привычки</h2>
                        <button id="add-habit-btn" class="btn primary-btn"><i class="fas fa-plus"></i> Добавить</button>
                    </div>
                    
                    <div id="habits-list" class="habits-list">
                        <!-- Здесь будут отображаться привычки -->
                    </div>
                </div>
                
                <div class="calendar-section">
                    <h2>Календарь отметок</h2>
                    <div class="calendar-controls">
                        <button id="prev-month" class="btn icon-btn"><i class="fas fa-chevron-left"></i></button>
                        <h3 id="current-month">Месяц Год</h3>
                        <button id="next-month" class="btn icon-btn"><i class="fas fa-chevron-right"></i></button>
                    </div>
                    <div id="calendar" class="calendar">
                        <!-- Здесь будет отображаться календарь -->
                    </div>

                    <!-- Добавленный блок списка выполненных привычек сегодня -->
                    <h3>Выполненные привычки сегодня:</h3>
                    <ul id="completed-today-list" class="completed-list"></ul>
                </div>
            </div>
        </div>
        
        <!-- Модальное окно для добавления/редактирования привычки -->
        <div id="habit-modal" class="modal">
            <div class="modal-content">
                <span class="close">&times;</span>
                <h2 id="habit-modal-title">Добавить привычку</h2>
                <form id="habit-form">
                    <input type="hidden" id="habit-id">
                    <div class="form-group">
                        <label for="habit-name">Название</label>
                        <input type="text" id="habit-name" required>
                    </div>
                    <div class="form-group">
                        <label for="habit-description">Описание</label>
                        <textarea id="habit-description" rows="3"></textarea>
                    </div>
                    <div class="form-actions">
                        <button type="button" id="cancel-habit" class="btn secondary-btn">Отмена</button>
                        <button type="submit" class="btn primary-btn">Сохранить</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <script src="api.js"></script>
    <script src="auth.js"></script>
    <script src="habits.js"></script>
    <script src="habits-handlers.js"></script>
    <script src="calendar.js"></script>
    <script src="app.js"></script>
</body>
</html>
</file>

<file path="frontend/nginx.conf">
server {
    listen 80;
    server_name _;

    # Отдаём статику
    root /usr/share/nginx/html;
    index index.html;

    # Сначала проксируем API
    location /api/ {
        # proxy_pass без суффикса /api/, чтобы path сохранялся
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Всё остальное — наш SPA
    location / {
        try_files $uri $uri/ /index.html;
    }
}
</file>

<file path="README_RUS.md">
# Трекер привычек

Простое приложение для формирования и поддержания ежедневных привычек. Создавайте, редактируйте, отмечайте выполнение и следите за прогрессом через календарь.

## Возможности

### Аутентификация
- **Регистрация**: создание аккаунта с именем пользователя и паролем
- **Вход**: доступ к личному кабинету
- **Выход**: завершение сессии

### Управление привычками
- **Создание**: добавление новой привычки с описанием
- **Редактирование**: изменение данных привычки
- **Удаление**: удаление привычек
- **Архивация**: перенос неактуальных привычек в архив

### Отслеживание прогресса
- **Отметки о выполнении**: пометка привычек как выполненных на выбранную дату
- **Календарь**: визуализация цепочек успехов
- **Список выполненных сегодня привычек**
- **Удаление отметки**: исправление ошибок

## Быстрый старт

### Требования

- Установлен Docker  
- Установлен Git

### Установка

```bash
git clone git@github.com:pyfig/habit_tracker.git
cd habit_tracker
./main.sh
```

- **Бэкенд**: http://localhost:8000  
- **Фронтенд**: http://localhost:3000  
- **База данных (PostgreSQL)**: порт 5432  


## Структура проекта

```
📦 habit_tracker
├─ backend/
├─ frontend/
├─ docker-compose.yml
├─ main.sh
├─ package.json
└─ README_RUS.md
```

## API

| Метод | Эндпоинт                        | Описание                    |
|-------|----------------------------------|------------------------------|
| POST  | `/api/auth/register`             | Регистрация нового пользователя |
| POST  | `/api/auth/login`                | Вход в систему               |
| GET   | `/api/habits`                    | Получить все привычки        |
| POST  | `/api/habits`                    | Создать новую привычку       |
| GET   | `/api/habits/{habit_id}`         | Получить данные о привычке   |
| PUT   | `/api/habits/{habit_id}`         | Обновить привычку            |
| DELETE| `/api/habits/{habit_id}`         | Удалить привычку             |
| POST  | `/api/marks`                     | Создать отметку              |
| GET   | `/api/marks/habit/{habit_id}`    | Получить все отметки привычки|
| DELETE| `/api/marks/{mark_id}`           | Удалить отметку              |

## Технологии

**Бэкенд**  
- FastAPI, Uvicorn, SQLAlchemy, PostgreSQL, Docker

**Фронтенд**  
- HTML5, CSS3, JavaScript, AJAX, FontAwesome, Vite

## Планы развития

- Автоматические тесты
- Восстановление привычек из архива
- Уведомления о привычках
- Просмотр статистики
- Удаление привычек
- Фильтрация привычек
- Просмотр архивированных привычек
- Статистика и аналитика
</file>

<file path="backend/app/main.py">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.routes import auth, habits, marks
from app.models import Base
from app.db import engine

# Создаем таблицы в базе данных
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Habit Tracker API")

# Настройка CORS
origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:80",
    "http://127.0.0.1:80",
    "http://localhost",
    "http://127.0.0.1",
    "http://localhost:*",
    "http://127.0.0.1:*"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Подключаем маршруты
app.include_router(auth.router, prefix="/api")
app.include_router(habits.router, prefix="/api")
app.include_router(marks.router, prefix="/api")


@app.get("/")
async def root():
    return {"message": "Welcome to Habit Tracker API"}
</file>

<file path="frontend/styles.css">
:root {
    --primary-color: #4a6fa5;
    --primary-dark: #3a5a8c;
    --secondary-color: #6c757d;
    --success-color: #60e980;
    --danger-color: #dc3545;
    --light-color: #f8f9fa;
    --dark-color: #343a40;
    --border-color: #dee2e6;
    --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    color: var(--dark-color);
    background-color: #f5f7fa;
    min-height: 100vh;
}

.app-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.container {
    background-color: white;
    border-radius: 8px;
    box-shadow: var(--shadow);
    padding: 30px;
    margin-bottom: 20px;
}

/* Кнопки */
.btn {
    display: inline-block;
    padding: 10px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s ease;
}

.primary-btn {
    background-color: var(--primary-color);
    color: white;
}

.primary-btn:hover {
    background-color: var(--primary-dark);
}

.secondary-btn {
    background-color: var(--secondary-color);
    color: white;
}

.secondary-btn:hover {
    background-color: #5a6268;
}

.icon-btn {
    background-color: transparent;
    color: var(--primary-color);
    padding: 5px 10px;
}

.icon-btn:hover {
    color: var(--primary-dark);
}

/* Формы */
.form-group {
    margin-bottom: 20px;
}

label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
}

input, textarea {
    width: 100%;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 16px;
}

input:focus, textarea:focus {
    outline: none;
    border-color: var(--primary-color);
}

/* Аутентификация */
#auth-container {
    max-width: 500px;
    margin: 50px auto;
}

.tabs {
    display: flex;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
}

.tab-btn {
    flex: 1;
    padding: 10px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    font-weight: 500;
    color: var(--secondary-color);
}

.tab-btn.active {
    color: var(--primary-color);
    border-bottom: 2px solid var(--primary-color);
}

.auth-form {
    display: none;
}

.auth-form.active {
    display: block;
}

.error-message {
    color: var(--danger-color);
    margin-top: 10px;
    font-size: 14px;
}

/* Основной контент */
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
}

.content-wrapper {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
}

@media (max-width: 768px) {
    .content-wrapper {
        grid-template-columns: 1fr;
    }
}

/* Секция привычек */
.habits-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.habits-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.habit-item {
    background-color: white;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    border-left: 4px solid var(--primary-color);
}

.habit-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.habit-title {
    font-size: 18px;
    font-weight: 600;
}

.habit-actions {
    display: flex;
    gap: 10px;
}

.habit-action {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    color: var(--secondary-color);
}

.habit-action:hover {
    color: var(--primary-color);
}

.habit-description {
    color: var(--secondary-color);
    font-size: 14px;
}

/* Календарь */
.calendar-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.calendar {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
}

.calendar-day {
    aspect-ratio: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 50%;
    font-size: 14px;
    cursor: pointer;
}

.calendar-day.today {
    border: 2px solid var(--primary-color);
}

.calendar-day.marked {
    background-color: var(--success-color);
    color: white;
}

.calendar-day.other-month {
    color: var(--secondary-color);
    opacity: 0.5;
}

.calendar-day:hover {
    background-color: var(--light-color);
}

.calendar-day.marked:hover {
    background-color: var(--success-color);
    opacity: 0.8;
}

.calendar-header {
    font-weight: bold;
    text-align: center;
    padding: 5px 0;
}

/* файл: frontend/styles.css */
/* Список выполненных сегодня привычек */
.completed-list {
    list-style-type: disc;
    padding-left: 20px;
    margin-top: 10px;
    color: var(--dark-color);
}
/* кнопка архивирования в списке выполненных сегодня */
.completed-list .archive-today-btn {
    margin-left: 10px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 0.9em;
    color: var(--danger-color);
  }
  .completed-list .archive-today-btn:hover {
    text-decoration: underline;
  }
  

/* Модальное окно */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
}

.modal-content {
    background-color: white;
    margin: 10% auto;
    padding: 30px;
    border-radius: 8px;
    max-width: 500px;
    box-shadow: var(--shadow);
    position: relative;
}

.close {
    position: absolute;
    right: 20px;
    top: 15px;
    font-size: 24px;
    cursor: pointer;
    color: var(--secondary-color);
}

.close:hover {
    color: var(--dark-color);
}

.form-actions {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
}


/* Утилиты */
.hidden {
    display: none;
}
</file>

<file path="backend/app/routes/habits.py">
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from uuid import UUID

from app.db import get_db
from app.models import Habit, User
from app.schemas import HabitCreate, HabitRead, HabitUpdate
from app.auth import get_current_user
from sqlalchemy.exc import IntegrityError

router = APIRouter(prefix="/habits", tags=["habits"])

@router.post("/", response_model=HabitRead)
async def create_habit(habit_data: HabitCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    try:
        new_habit = Habit(
            user_id=current_user.id,
            name=habit_data.name,
            description=habit_data.description
        )
        db.add(new_habit)
        db.commit()
        db.refresh(new_habit)
        return new_habit
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Habit already exists or other integrity error")

@router.get("/", response_model=List[HabitRead])
async def get_habits(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    # Возвращаем только активные (неархивные) привычки
    habits = (
        db.query(Habit)
          .filter(Habit.user_id == current_user.id, Habit.archived == False)
          .all()
    )
    return habits

@router.get("/{habit_id}", response_model=HabitRead)
async def get_habit(habit_id: UUID, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    habit = db.query(Habit).filter(Habit.id == habit_id, Habit.user_id == current_user.id).first()
    if not habit:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Habit not found")
    return habit

@router.put("/{habit_id}", response_model=HabitRead)
async def update_habit(habit_id: UUID, habit_data: HabitUpdate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    habit = db.query(Habit).filter(Habit.id == habit_id, Habit.user_id == current_user.id).first()
    if not habit:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Habit not found")
    
    for key, value in habit_data.dict(exclude_unset=True).items():
        setattr(habit, key, value)
    
    db.commit()
    db.refresh(habit)
    return habit

@router.delete("/{habit_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_habit(habit_id: UUID, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    habit = db.query(Habit).filter(Habit.id == habit_id, Habit.user_id == current_user.id).first()
    if not habit:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Habit not found")
    
    db.delete(habit)
    db.commit()
    return None

@router.post("/{habit_id}/archive", status_code=status.HTTP_204_NO_CONTENT)
async def archive_habit(habit_id: UUID, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    habit = db.query(Habit).filter(Habit.id == habit_id, Habit.user_id == current_user.id).first()
    if not habit:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Habit not found or doesn't belong to current user")
    
    
    habit.archived = True  
    db.commit()
    db.refresh(habit)
    return None

@router.post("/{habit_id}/complete", status_code=status.HTTP_204_NO_CONTENT)
async def complete_habit(
    habit_id: UUID, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)
):
    habit = db.query(Habit).filter(Habit.id == habit_id, Habit.user_id == current_user.id).first()
    if not habit:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Habit not found or doesn't belong to current user")
    
    # Помечаем привычку как выполненную
    habit.completed = True  
    db.commit()
    db.refresh(habit)
    return None
</file>

<file path="frontend/habits.js">
// apiClient.js

const API_URL = 'http://localhost:8000/api';

class ApiClient {
  constructor(baseURL = API_URL) {
    this.baseURL = baseURL;
    this.tokenKey = 'auth_token';
  }

  // Получить токен из localStorage
  get token() {
    return localStorage.getItem(this.tokenKey);
  }

  // Сохранить токен
  set token(value) {
    if (value) {
      localStorage.setItem(this.tokenKey, value);
    } else {
      localStorage.removeItem(this.tokenKey);
    }
  }

  // Универсальный метод запросов
  async request(endpoint, { method = 'GET', data = null } = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const headers = { 'Content-Type': 'application/json' };

    if (this.token) {
      headers['Authorization'] = `Bearer ${this.token}`;
    }

    const config = {
      method,
      headers,
      credentials: 'include'
    };

    if (data && ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase())) {
      config.body = JSON.stringify(data);
    }

    console.debug('[API Request]', method, url, data ? data : '');

    const res = await fetch(url, config);

    // 204 No Content
    if (res.status === 204) {
      return null;
    }

    let payload;
    try {
      payload = await res.json();
    } catch {
      throw new Error(`Invalid JSON in response from ${endpoint}`);
    }

    if (!res.ok) {
      const msg = payload.detail || payload.message || res.statusText;
      throw new Error(`API Error (${res.status}): ${msg}`);
    }

    return payload;
  }

  // Аутентификация
  async login(username, password) {
    const data = await this.request('/auth/login', {
      method: 'POST',
      data: { username, password }
    });
    if (data.token) this.token = data.token;
    return data;
  }

  async register(username, password) {
    const data = await this.request('/auth/register', {
      method: 'POST',
      data: { username, password }
    });
    if (data.token) this.token = data.token;
    return data;
  }
  async completeHabit(id) {
    return this.request(`/habits/${id}/complete`, {
      method: 'POST'
    });
  }  
  async logout() {
    this.token = null;
  }

  // Привычки
  async getHabits() {
    return this.request('/habits', { method: 'GET' });
  }

  async getHabitById(id) {
    return this.request(`/habits/${id}`, { method: 'GET' });
  }

  // Обновленный метод createHabit с обработкой ошибок
  async createHabit(habit) {
    try {
      const data = await this.request('/habits', {
        method: 'POST',
        data: habit
      });
      console.log('Привычка успешно создана:', data);
      return data;
    } catch (error) {
      console.error('Ошибка создания привычки:', error);
      throw new Error('Не удалось сохранить привычку');
    }
  }
  
  // Добавлена синхронизация данных календаря
  async syncCalendar(habitId) {
    const marks = await this.getMarks(habitId);
    // Логика обновления интерфейса календаря
    return marks;
  }

  async updateHabit(id, habit) {
    return this.request(`/habits/${id}`, {
      method: 'PUT',
      data: habit
    });
  }

  async deleteHabit(id) {
    return this.request(`/habits/${id}`, { method: 'DELETE' });
  }

  // Отметки
  async getMarks(habitId) {
    return this.request(`/marks/habit/${habitId}`, { method: 'GET' });
  }

  async createMark(mark) {
    return this.request('/marks', {
      method: 'POST',
      data: mark
    });
  }

  async deleteMark(id) {
    return this.request(`/marks/${id}`, { method: 'DELETE' });
  }
}

// Создаем глобальный экземпляр API клиента
const api = new ApiClient();

// Делаем методы API доступными глобально
const habitsApi = {
  getAll: (token) => api.getHabits(),
  getById: (id, token) => api.getHabitById(id),
  create: (habitData, token) => api.createHabit(habitData),
  update: (id, habitData, token) => api.updateHabit(id, habitData),
  delete: (id, token) => api.deleteHabit(id),
  complete: (id, token) => api.completeHabit(id)  // ← вот это добавляем!
};

// API для работы с отметками
const marksApi = {
  getByHabit: (habitId, token) => api.getMarks(habitId),
  create: (markData, token) => api.createMark(markData),
  delete: (id, token) => api.deleteMark(id)
};
</file>

<file path="frontend/api.js">
// API URL
const API_URL = 'http://localhost:8000/api';

// Функция для выполнения запросов к API
async function apiRequest(endpoint, method = 'GET', data = null, token = null) {
    const headers = {
        'Content-Type': 'application/json'
    };
    
    if (token) {
        headers['Authorization'] = `Bearer ${token}`;
    }
    
    const config = {
        method,
        headers,
        credentials: 'include'
    };
    
    if (data && (method === 'POST' || method === 'PUT')) {
        config.body = JSON.stringify(data);
    }
    
    try {
        console.log('Request:', `${API_URL}${endpoint}`, config);
        const response = await fetch(`${API_URL}${endpoint}`, config);
        
        if (response.status === 204) {
            return { success: true };
        }
        
        const result = await response.json();
        console.log('Response:', result);
        
        if (!response.ok) {
            throw new Error(result.detail || 'Произошла ошибка при выполнении запроса');
        }
        
        return result;
    } catch (error) {
        console.error('API Error:', error);
        throw new Error(`API Error: ${error.message} (endpoint: ${endpoint})`);
    }
}

// API для аутентификации
const authApi = {
    login: async (username, password) => {
        return apiRequest('/auth/login', 'POST', { username, password });
    },
    
    register: async (username, password) => {
        return apiRequest('/auth/register', 'POST', { username, password });
    }
};


// API для работы с привычками
const habitsApi = {
    getAll: async (token) => {
        return apiRequest('/habits', 'GET', null, token);
    },
    getById: async (id, token) => {
        return apiRequest(`/habits/${id}`, 'GET', null, token);
    },
    create: async (habitData, token) => {
        return apiRequest('/habits', 'POST', habitData, token);
    },
    update: async (id, habitData, token) => {
        return apiRequest(`/habits/${id}`, 'PUT', habitData, token);
    },
    delete: async (id, token) => {
        return apiRequest(`/habits/${id}`, 'DELETE', null, token);
    },
    archive: async (id, token) => {
        return apiRequest(`/habits/${id}/archive`, 'POST', null, token);
    },
    complete: async (id, token) => {
        return apiRequest(`/habits/${id}/complete`, 'POST', null, token);
    }    
};




// API для работы с отметками
const marksApi = {
    // Получение всех отметок по привычке (сейчас путь /api/marks/habit/{habitId})
    getByHabit: async (habitId, token) => {
      return apiRequest(`/marks/habit/${habitId}`, 'GET', null, token);
    },
  
    // Создание новой отметки (используем переданную дату date)
    create: async (markData, token) => {
      return apiRequest('/marks', 'POST', markData, token);
    },
  
    // Удаление отметки по id
    delete: async (id, token) => {
      return apiRequest(`/marks/${id}`, 'DELETE', null, token);
    }
  };
</file>

<file path="frontend/habits-handlers.js">
// Управление привычками на фронтенде
const habitsList = document.getElementById('habits-list');
const addHabitBtn = document.getElementById('add-habit-btn');
const habitForm = document.getElementById('habit-form');
const habitModal = document.getElementById('habit-modal');
const modalCloseBtn = habitModal.querySelector('.close');
const cancelHabitBtn = document.getElementById('cancel-habit');

let habits = [];

// Открытие модального окна
function openHabitModal(editingId = null) {
  // Сброс формы
  habitForm.reset();
  delete habitForm.dataset.editing;
  document.getElementById('habit-modal-title').textContent = editingId ? 'Редактировать привычку' : 'Добавить привычку';
  if (editingId) habitForm.dataset.editing = editingId;
  habitModal.style.display = 'block';
}

// Закрытие модального окна
function closeHabitModal() {
  habitModal.style.display = 'none';
}

// Загрузка привычек при инициализации

async function loadHabits() {
    try {
        const token = getToken();
        habits = await habitsApi.getAll(token);
        // Фильтруем архивные привычки: показываем только active
        habits = habits.filter(habit => !habit.archived);
        renderHabits();
        renderCompletedToday();
    } catch (error) {
        console.error('Ошибка при загрузке привычек:', error);
    }
}

// Отображение списка привычек
function renderHabits() {
    habitsList.innerHTML = '';

    // Отбираем привычки, которые НЕ архивированы и НЕ выполнены
    const activeHabits = habits.filter(habit => !habit.archived && !habit.completed);

    if (activeHabits.length === 0) {
        habitsList.innerHTML = '<div class="empty-state">У вас пока нет активных привычек.</div>';
        return;
    }

    activeHabits.forEach(habit => {
        const habitElement = document.createElement('div');
        habitElement.className = 'habit-item';
        habitElement.innerHTML = `
            <div class="habit-info">
                <h3>${habit.name}</h3>
                <p>${habit.description || ''}</p>
            </div>
            <div class="habit-actions">
                <button class="btn icon-btn edit-habit" data-id="${habit.id}"><i class="fas fa-edit"></i></button>
                <button class="btn icon-btn archive-habit" data-id="${habit.id}"><i class="fas fa-archive"></i></button>
                <button class="btn icon-btn delete-habit" data-id="${habit.id}"><i class="fas fa-trash"></i></button>
                <button class="btn icon-btn complete-habit" data-id="${habit.id}"><i class="fa-solid fa-circle-check"></i></button>
            </div>
        `;

        habitsList.appendChild(habitElement);

        habitElement.querySelector('.complete-habit').addEventListener('click', () => completeHabit(habit.id));
        habitElement.querySelector('.edit-habit').addEventListener('click', () => openHabitModal(habit.id));
        habitElement.querySelector('.delete-habit').addEventListener('click', () => deleteHabit(habit.id));
        habitElement.querySelector('.archive-habit').addEventListener('click', () => archiveHabit(habit.id));
    });
}



async function loadHabits() {
    try {
        const token = getToken();
        habits = await habitsApi.getAll(token);
        habits = habits.filter(habit => !habit.archived);
        renderHabits();
        renderCompletedToday();
    } catch (error) {
        console.error('Ошибка при загрузке привычек:', error);
    }
}





// Добавление новой привычки
async function addHabit() {
    const name = document.getElementById('habit-name').value.trim();
    const description = document.getElementById('habit-description').value.trim();
    if (!name) {
        alert('Название привычки не может быть пустым.');
        return;
    }
    try {
        const token = getToken();
        const newHabit = await habitsApi.create({ name, description }, token);
        habits.push(newHabit);
        renderHabits();
        closeHabitModal();
    } catch (error) {
        console.error('Ошибка при добавлении привычки:', error);
        alert('Не удалось добавить привычку. Попробуйте еще раз.');
    }
}

// Обновление привычки
async function updateHabit(habitId) {
    const name = document.getElementById('habit-name').value.trim();
    const description = document.getElementById('habit-description').value.trim();
    if (!name) {
        alert('Название привычки не может быть пустым.');
        return;
    }
    try {
        const token = getToken();
        const updated = await habitsApi.update(habitId, { name, description }, token);
        const idx = habits.findIndex(h => h.id === habitId);
        habits[idx] = updated;
        renderHabits();
        closeHabitModal();
    } catch (error) {
        console.error('Ошибка при обновлении привычки:', error);
        alert('Не удалось обновить привычку. Попробуйте еще раз.');
    }
}

habitForm.addEventListener('submit', event => {
    event.preventDefault();
    const editingId = habitForm.dataset.editing;
    if (editingId) updateHabit(editingId);
    else addHabit();
});

addHabitBtn.addEventListener('click', () => openHabitModal());
modalCloseBtn.addEventListener('click', closeHabitModal);
cancelHabitBtn.addEventListener('click', closeHabitModal);
window.addEventListener('click', event => {
  if (event.target === habitModal) closeHabitModal();
});

async function archiveHabit(habitId) {
    if (!confirm('Вы уверены, что хотите архивировать эту привычку?')) return;
    try {
        const token = getToken();
        await habitsApi.archive(habitId, token);
        habits = habits.filter(habit => habit.id !== habitId);
        renderHabits();
        renderCompletedToday();
    } catch (error) {
        console.error('Ошибка при архивировании привычки:', error);
        alert('Не удалось архивировать привычку. Попробуйте еще раз.');
    }
}

async function deleteHabit(habitId) {
    if (!confirm('Удалить эту привычку?')) return;
    try {
        const token = getToken();
        await habitsApi.delete(habitId, token);
        habits = habits.filter(habit => habit.id !== habitId);
        renderHabits();
        renderCompletedToday();
    } catch (error) {
        console.error('Ошибка при удалении привычки:', error);
        alert('Не удалось удалить привычку. Попробуйте ещё раз.');
    }
}



async function completeHabit(habitId) {
    console.log('Complete clicked', habitId);
    try {
        const token = getToken();
        await habitsApi.complete(habitId, token);
        console.log('Complete API request done');

        const completedHabit = habits.find(h => h.id === habitId);
        if (completedHabit) {
            completedHabit.completed = true;  // ← ставим галочку
        }

        renderHabits();          // обновляем активные привычки
        renderCompletedToday();  // обновляем выполненные привычки
    } catch (error) {
        console.error('Ошибка при выполнении привычки:', error);
        alert('Не удалось отметить привычку как выполненную.');
    }
}




// Инициализация
loadHabits();
</file>

<file path="README.md">
# README.md (English)

# Habit Tracker

Simple and intuitive app to form and maintain daily habits. Create, edit, track progress in the calendar, and see completed habits for today.

## Features

### Authentication
- **Register**: create a new account with username and password
- **Login**: access your personal habit tracker
- **Logout**: securely end your session

### Habit Management
- **Create**: add a new habit with name and optional description
- **Edit**: update habit details
- **Delete**: remove unnecessary habits
- **Archive**: move inactive habits to archive

### Progress Tracking
- **Mark Completion**: mark a habit as completed on a selected day
- **Calendar View**: visualize your streaks and history
- **Today's Completed Habits**: see a list of today's successes
- **Remove Mark**: undo wrong marks

## Quick Start

### Requirements

- Docker  
- Git

### Installation

```bash
git clone git@github.com:pyfig/habit_tracker.git
cd habit_tracker
./main.sh
```

- **Backend**: http://localhost:8000  
- **Frontend**: http://localhost:3000  
- **Database**: port 5432


## Project Structure

```
📦 habit_tracker
├─ backend/
├─ frontend/
├─ docker-compose.yml
├─ main.sh
├─ package.json
└─ README.md
```

## API Overview

| Method | Endpoint                     | Description                 |
|--------|------------------------------|-----------------------------|
| POST   | `/api/auth/register`         | Register new user           |
| POST   | `/api/auth/login`            | Login user                  |
| GET    | `/api/habits`                | Get all habits              |
| POST   | `/api/habits`                | Create a new habit          |
| GET    | `/api/habits/{habit_id}`     | Get habit details           |
| PUT    | `/api/habits/{habit_id}`     | Update habit                |
| DELETE | `/api/habits/{habit_id}`     | Delete habit                |
| POST   | `/api/marks`                 | Create a mark (track habit) |
| GET    | `/api/marks/habit/{habit_id}`| Get all marks for habit     |
| DELETE | `/api/marks/{mark_id}`       | Delete a mark               |

## Technologies

**Backend**  
- FastAPI, Uvicorn, SQLAlchemy, PostgreSQL, Docker

**Frontend**  
- HTML5, CSS3, JavaScript, AJAX, FontAwesome, Vite

## Roadmap

- Automatic tests
- Habit archive browsing
- Habit recovery from archive
- Mobile optimization
- Analytics and statistics

---
</file>

</files>
